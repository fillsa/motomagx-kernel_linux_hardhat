/*
 * Copyright (C) 2005-2008 Motorola, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
 *
 * Motorola 2008-Jun-17 - Protect BIASEN, BIASSPEED & MC2BEN bits during 3mm5 headset debouncing
 * Motorola 2008-Jun-17 - Improve error checking.
 * Motorola 2008-Jun-17 - Add support for normally open 3.5 mm headsets
 * Motorola 2008-May-15 - Reset audio AHS bits if they get auto cleared
 * Motorola 2007-Jan-25 - Add support for power management 
 * Motorola 2007-Jan-08 - Updated copyright
 * Motorola 2006-Oct-10 - Update File
 * Motorola 2006-Sep-19 - Replace headset_key_handler() and power_key_event() with generate_key_event()
 * Motorola 2006-Jul-31 - Update comments
 * Motorola 2006-May-17 - Fix unused function warning.
 * Motorola 2006-Apr-20 - Add 3.5mm headset support
 * Motorola 2005-Oct-15 - Finalized the software.
 * Motorola 2005-Jun-16 - Added ATLAS support
 * Motorola 2005-Feb-28 - Rewrote the software.
 */

/*!
 * @file debounce.c
 *
 * @ingroup poweric_debounce
 *
 * @brief This is the main file of the power IC debouncing routines
 *
 * This file handles the debouncing of various interrupts from the power IC.
 * The module is desgined to be as generic as possible, with a table that
 * defines the interrupts that are to be monitored (debounced) along with
 * a callback function to be called when a change to the signal has been
 * fully debounced.
 *
 * Currently, this file handles debouncing of the power key, barrel headset,
 * and barrel headset send/end key.  In the future, stereo headset detection
 * will need to be added as well.
 */

/*******************************************************************************
* Includes
*******************************************************************************/
#include <linux/delay.h>
#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/wait.h>
#include <linux/interrupt.h>
#include <linux/module.h>
#include <linux/keypad.h>
#include <linux/timer.h>
#include <linux/sched.h>
#include <asm/semaphore.h>

#include <linux/power_ic.h>
#include <linux/power_ic_audio.h>
#include <linux/power_ic_kernel.h>
#include <linux/moto_accy.h>

#include "../core/event.h"
#include "../core/os_independent.h"
#include "../core/thread.h"
#include "audio.h"
#include "debounce.h"

/*******************************************************************************
* Type definitions
*******************************************************************************/

/*!
 * @brief Structure defining a power IC event to debounce
 */
typedef struct debounce_event_t
{
    POWER_IC_EVENT_T event;      /*!< power IC event to debounce */
    int primary_event;           /*!< 1 = the primary event generated by an interrupt,
                                      0 = a secondary event generated by debounce code */

    int spi_bit_mask;            /*!< power IC SPI bit mask */

    int enabled;                 /*!< 1 = event is enabled, 0 = disabled */

    int poll_period;             /*!< polling period (in milliseconds) */
    int poll_count;              /*!< number of samples to take,
                                      there is no delay before the first sample.
                                      A poll count of 0 is used when a handler
                                      only needs a delay without debounced sample */

    int polarity;                /*!< Active high (0) or low (1)*/

    void (*callback)(struct debounce_event_t *, int status); /*!< function to call when polling complete */
    void (*pre_debounce)(void);  /*!< function to call before debouncing begins */
    void (*event_init)(void);    /*!< function to initialize variables hardware for an event handler */

    /* Entries after this point should not be initialized in debounce_events */

    int poll_current;            /*!< the current polling counter */
    int previous_status;         /*!< previous state of the event */
    int further_handling_needed; /*!< 1 = more debouncing needed on event,
                                      0 = handling of event is complete */

    struct timer_list timer;     /*!< timer used for this event */
} DEBOUNCE_EVENT_T;

/*!
 * @brief Enumeration that represents each event that needs to be debounced.
 */
typedef enum
{
    DEBOUNCE_EVENT_INDEX_POWER,
    DEBOUNCE_EVENT_INDEX_HEADSET,
    DEBOUNCE_EVENT_INDEX_MB2I,
    DEBOUNCE_EVENT_INDEX_MB2I_DELAY,
    DEBOUNCE_EVENT_INDEX_MB2I_FINAL,
    
    DEBOUNCE_EVENT_INDEX__NUM
} DEBOUNCE_EVENT_INDEX_T;

typedef enum
{
    HEADSET_KEY_UNKNOWN,
    HEADSET_KEY_PRESS,
    HEADSET_KEY_RELEASE,
    HEADSET_KEY_IGNORE
} HEADSET_KEY_STATE_T;

/*******************************************************************************
* Function Prototypes
*******************************************************************************/
static DEBOUNCE_EVENT_INDEX_T get_event_index(int event);
static int debounce_thread(void *unused);
static void add_index(DEBOUNCE_EVENT_INDEX_T index);
static int debounce_interrupt_handler(POWER_IC_EVENT_T event);
static void debounce_timer_handler(unsigned long i);
static void power_key_handler(DEBOUNCE_EVENT_T *event, int status);
static void headset_3mm5_pre_debounce(void);
static void headset_3mm5_handler(DEBOUNCE_EVENT_T *event, int status);
static void setup_for_next_handler(DEBOUNCE_EVENT_INDEX_T index, DEBOUNCE_EVENT_INDEX_T next_index);
static void headset_key_preliminary_handler(DEBOUNCE_EVENT_T *event, int status);
static void headset_key_delay_handler(DEBOUNCE_EVENT_T *event, int status);
static void headset_key_final_handler(DEBOUNCE_EVENT_T *event, int status);
static void headset_3mm5_init(void);

/*******************************************************************************
* Macros and Constants
*******************************************************************************/
/*! Event table */
static DEBOUNCE_EVENT_T debounce_events[] =
{
    /* On/Off key handler */
    { POWER_IC_EVENT_ATLAS_ONOFD1I,
      1,
      POWER_IC_ONOFF_MASK,
      1,
      10,
      2,
      0,
      power_key_handler,
      NULL,
      NULL},
    
    /* 3.5 mm headset handler */
    { POWER_IC_EVENT_ATLAS_HSDETI,
      1,
      POWER_IC_HSDET_MASK,
      1,
      300,
      3,
      0,
      headset_3mm5_handler,
      headset_3mm5_pre_debounce,
      headset_3mm5_init},
    
    /* 3.5 mm headset send/end key handlers */
    { POWER_IC_EVENT_ATLAS_MC2BI,
      1,
      POWER_IC_MB2_MASK,
      0,
      10,
      3,
      0,
      headset_key_preliminary_handler,
      NULL,
      NULL},
    
    { POWER_IC_EVENT_ATLAS_MC2BI,
      0,
      POWER_IC_MB2_MASK,
      0,
      500,
      0,
      0,
      headset_key_delay_handler,
      NULL,
      NULL},
    
    { POWER_IC_EVENT_ATLAS_MC2BI,
      0,
      POWER_IC_MB2_MASK,
      0,
      10,
      3,
      0,
      headset_key_final_handler,
      NULL,
      NULL},
    
    /* End of table -- insert new entries before this one */
    { POWER_IC_EVENT_NUM_EVENTS,
      0,
      0,
      0,
      0,
      0,
      0,
      NULL,
      NULL,
      NULL}
};

/*!
 * @brief Converts milliseconds to jiffies
 *
 *Accepts a parameter in units of milliseconds and defines value in jiffies
 */
#define TO_JIFFIES(msec) (1 + (((msec) * HZ) / 1000))
/*!
 * @brief Defines maximum number of events allowed in queue
 */
#define QUEUE_MAX_EVENTS 16

/*******************************************************************************
* Global Variables
*******************************************************************************/
/* Declare a flag to indicate 3mm5 headset is debouncing */
unsigned char power_ic_debouncing_3mm5_headset=0;                          

#ifndef DOXYGEN_SHOULD_SKIP_THIS
/*! @brief Mutex needed to protect power IC during 3mm5 headset debouncing */
DECLARE_MUTEX(power_ic_debounce_audio_mutex);
#endif

/*******************************************************************************
* Local Variables
*******************************************************************************/
/* doxygen is confused by the following definition since it looks like a function */
#ifndef DOXYGEN_SHOULD_SKIP_THIS
/*! @brief Mutex needed to protect accesses to the debouncer. */
static DECLARE_MUTEX(debounce_access_mutex);

/* Declare a wait queue used to signal arriving events to the handler thread */
static DECLARE_WAIT_QUEUE_HEAD(debounce_wait);

#endif

/*! Array location of the head of the queue */
static int queue_head = 0;

/*! Array location of the tail of the queue */
static int queue_tail = 0;

/*! The event queue array */
static DEBOUNCE_EVENT_INDEX_T event_queue[QUEUE_MAX_EVENTS];

/* Event table (defined later in the file) */
static DEBOUNCE_EVENT_T debounce_events[];

/* Stores information about the headset send/end key */
static HEADSET_KEY_STATE_T previous_key_state = HEADSET_KEY_UNKNOWN;

/*******************************************************************************
* Local Functions
*******************************************************************************/
/*!
 * @brief Take an event and returns the event index for the debounce_events
 * table.
 *
 * @param event
 *
 * @returns index
 */
static DEBOUNCE_EVENT_INDEX_T get_event_index(int event)
{
    DEBOUNCE_EVENT_INDEX_T i = 0;
    
    /* If the end of the table has not been reached, the event has not been
       found and this table entry is not the primary event, increment the
       counter to continue searching for a match */
    while (i < DEBOUNCE_EVENT_INDEX__NUM)
    {
        if ((debounce_events[i].event == event) &&
            (debounce_events[i].primary_event == 1))
        {
            break;
        }
        
        i++;
    }
    return i;
}

/*!
 * @brief the kernel thread responsible for debouncing
 *
 * This function implements the thread responsible for the majority of the
 * debounce handling.  The thread consists of an infinite loop that will
 * wait for interrupts and/or timer expirations.
 *
 * When an event arrives, it is placed into a queue and then the thread is
 * woken up.  When the thread wakes up, it takes events off of the queue and
 * handles them.  For each event handled, the current interrupt sense bit is
 * compared with the previous state of the sense bit.  If the sense bit stays
 * in the same state for X consecutive iterations (where X is defined on a
 * per-event basis), the callback function is called for the event.
 *
 * When not debouncing, the only thing that would cause the thread to start
 * running is an interrupt from the power IC.  While it is in the process or
 * debouncing an event, the event's interrupt is masked and a timer is used
 * to periodically poll the state of the sense bit.  Once debouncing is
 * complete, the interrupt is unmasked.
 *
 * In order to try to eliminate any interrupt race conditions, the interrupt
 * flag is always cleared whenever the interrupt sense is read.  Then, when
 * the interrupt is unmasked, the status is NOT cleared.  This will cause
 * the interrupt to fire immediately if the interrupt sense were to have
 * changed between the time it was last read and the time that the
 * interrupt was unmasked.
 *
 * @param unused An unused parameter
 *
 * @returns 0, but should never actually return
 */
static int debounce_thread (void *unused)
{
    DEBOUNCE_EVENT_INDEX_T i;
    int status = -1;

    /* Usual thread setup. */
    thread_common_setup("kdebounced");
    if(thread_set_realtime_priority(THREAD_PRIORITY_DEBOUNCE) != 0)
    {
        tracemsg(_k_d("Debounce thread - error setting thread priority."));
    }

    /*
     * Loop unless an abort siganl is received.  All signals, but the abort signals are
     * masked off in the common setup.  As a result only abort signals can be pending.
     */
    while(!signal_pending(current))
    {
        /* Iterate over the queue of pending events */
        while (queue_head != queue_tail)
        {
            /* Aquire the mutex */
            down(&debounce_access_mutex);
            {
                /* Grab the first entry and remove it from the queue */
                i = event_queue[queue_head];
                queue_head = (queue_head + 1) % QUEUE_MAX_EVENTS;
            }
            /* Release the mutex */
            up(&debounce_access_mutex);
                
            /* Only process the event if we found it in the table and it is enabled */
            if ((i < DEBOUNCE_EVENT_INDEX__NUM) && (debounce_events[i].enabled))
            {
                /* Check if debouncing has begun */
                if ((debounce_events[i].poll_current == 0) && (debounce_events[i].pre_debounce != NULL))
                {
                    /* Since debouncing is just starting, call the pre_debounce function */
                    debounce_events[i].pre_debounce();
                }

                /* A poll_count value of 0 means that the event handler only needs a delay,
                   not a debounced value */
                if (debounce_events[i].poll_count != 0)
                {
                    /* Read the sense bit from the power IC */
                    power_ic_event_clear (debounce_events[i].event);
                    status = power_ic_event_sense_read (debounce_events[i].event);

                    /* If the status is the same as the previous status, increment the counter */
                    if (status == debounce_events[i].previous_status &&
                        debounce_events[i].poll_current <= debounce_events[i].poll_count)
                    {
                        debounce_events[i].poll_current++;
                    }
                    /* Else, reset the counter and the previous status variable */
                    else
                    {
                        debounce_events[i].poll_current = 1;
                        debounce_events[i].previous_status = status;
                    }
                }

                /* Check to see if the polling counter has reached its limit */
                if (debounce_events[i].poll_current > debounce_events[i].poll_count)
                {
                    /* Make sure our callback is valid. */
                    if (debounce_events[i].callback != NULL)
                    {
                        /* Since we're done debouncing, call the callback function */
                        debounce_events[i].callback(&(debounce_events[i]), status);
                    }

                    /* Make sure the event is completely handled */
                    if (debounce_events[i].further_handling_needed == 0)
                    {
                        /* Reenable the interrupt */
                        power_ic_event_unmask(debounce_events[i].event);

                        /* Release power management */
                        if (debounce_events[i].event >= POWER_IC_EVENT_ATLAS_SECOND_REG)
                        {
                            /* Clear the suspend bit in the suspend mask for interrupt 1 */
                            power_ic_pm_suspend_mask_tbl[POWER_IC_PM_INTERRUPT_1] &= ~(debounce_events[i].spi_bit_mask);
                        }
                        else
                        {
                            /* Clear the suspend bit in the suspend mask for interrupt 0 */
                            power_ic_pm_suspend_mask_tbl[POWER_IC_PM_INTERRUPT_0] &= ~(debounce_events[i].spi_bit_mask);
                        }
                    }

                    /* Reset the variables */
                    debounce_events[i].poll_current = 0;
                    debounce_events[i].previous_status = -1;
                    debounce_events[i].further_handling_needed = 0;
                }

                /* Else, need to keep polling, so start a timer */
                else
                {
                    if (debounce_events[i].poll_count == 0)
                    {
                        debounce_events[i].poll_current = 1;
                    }
                    
                    /* Set the expiration time */
                    debounce_events[i].timer.expires =
                        jiffies + TO_JIFFIES(debounce_events[i].poll_period);

                    /* Add the timer to the list */
                    add_timer (&(debounce_events[i].timer));
                }
            }
        }
        /* Sleep if there are no more events waiting on the queue or a signal is received. */
        (void)wait_event_interruptible (debounce_wait, (queue_head != queue_tail));
    }

    return 0;
}

/*!
 * @brief adds an event to the event queue
 *
 * This function adds an event to the event queue for the debouncing thread.
 * The ordering of the events in the queue doesn't really matter too much
 * since all of the pending events will be handled by the thread during one
 * iteration.
 *
 * This function checks to see if the queue is full by checking to see if
 * incrementing the tail pointer will make the tail equal to the head
 * pointer.  When the tail and head are equal, it means that the queue
 * is empty, so if incrementing the tail would make it equal to the head,
 * it means that the queue is full and new events cannot be added.
 *
 * The queue is currently large enough so that it is impossible for the
 * queue to fill up.  If in the future many additional events are added
 * into the event table, the queue size may need to be increased.
 *
 * @param index the index of the table entry to add to the queue
 */
static void add_index(DEBOUNCE_EVENT_INDEX_T index)
{
    int next_event = (queue_tail + 1) % QUEUE_MAX_EVENTS;

    /* Acquire mutex for protecting the thread queue */
    down(&debounce_access_mutex);
    {
        /* Add the event to the queue if it isn't already full, and if the index is valid. */
        if ((next_event != queue_head) && (index < DEBOUNCE_EVENT_INDEX__NUM))
        {
            /* Store the event into the queue */
            event_queue[queue_tail] = index;
            
            /* Update the tail pointer */
            queue_tail = next_event;
        }
        /* Release mutex */
        up(&debounce_access_mutex);
    }

    /* Wake up the thread if thread is sleeping */
    wake_up (&debounce_wait);
}

/*!
 * @brief the event handler for all of the power IC events being debounced
 *
 * This is the power IC event handler for the events registered by the debouncing
 * code.  The function simply adds the event to the queue (which will cause the
 * thread to be woken up to process the event).
 *
 * @param event power IC that occurred
 *
 * @return 1 to indicate that the event has been handled
 */
static int debounce_interrupt_handler(POWER_IC_EVENT_T event)
{
    /* Add debounce table entry to the queue */
    add_index(get_event_index(event));

    return 1;
}

/*!
 * @brief the handler for a debounce timer expiration
 *
 * This is the timer event handler for the events registered by the debouncing
 * code.  The function simply adds the debounce index to the queue (which will
 * cause the thread to be woken up to process the timer expiration). Timers are
 * not cyclic, so when the timer expires, it must be restarted by hand before
 * it will "fire" again.  This is handled by the debouncing thread.
 *
 * @param i entry in the event table that this timer expiration is for
 */
static void debounce_timer_handler(unsigned long i)
{
    /* Add the index to the queue */
    add_index(i);
}

/*!
 * @brief callback function to indicate power key status
 *
 * This function is called when the status of the power key changes.  The
 * function will report the new state of the power key to the keypad handling
 * code for furture processing.
 *
 * @param event pointer to the location in the event table
 * @param status current status of the power key
 *
 * @note The filtering of the power key when the flip is closed is done in 
 *       drivers/char/mot_keyb.c so if the keycode is changed in this function,
 *       it must also be changed in mot_keyb.c
 */
static void power_key_handler (DEBOUNCE_EVENT_T *event, int status)
{
    /* Status is reverse-polarity: 1 = not pressed */
    if (status != debounce_events[DEBOUNCE_EVENT_INDEX_POWER].polarity)
    {
        tracemsg(_k_d("power_key_debounced: key is released"));
        generate_key_event(KEYPAD_HANGUP, KEYUP);
    }
    else
    {
        tracemsg(_k_d("power_key_debounced: key is pressed"));
        generate_key_event(KEYPAD_HANGUP, KEYDOWN);
    } 
}

/*!
 * @brief Configures Atlas for 3.5mm headset detection
 *
 * This function is called before the HSDET sense bit is debounced. This function
 * will configure Atlas to allow detection of the headset with mic and headset
 * without mic. The time spent debouncing the HSDET sense bit is also used as
 * delay to allow the MC2B line to settle after this configuration.
 */
static void headset_3mm5_pre_debounce(void)
{   
    /* Aquire the mutex */
    down(&power_ic_debounce_audio_mutex);
    {    
        /* 3mm5 headset debouncing started */
        power_ic_debouncing_3mm5_headset=1;

        /* Mask the mic bias interrupt */
        power_ic_event_mask(POWER_IC_EVENT_ATLAS_MC2BI);

        /* Set BIASEN and BIASSPEED bits in Atlas */
        power_ic_set_reg_mask(POWER_IC_REG_ATLAS_AUDIO_RX_0,
                             (POWER_IC_AUDIO_REG_AUDIO_RX_0_BIASEN |
                              POWER_IC_AUDIO_REG_AUDIO_RX_0_BIASSPEED),
                             (POWER_IC_AUDIO_REG_AUDIO_RX_0_BIASEN |
                              POWER_IC_AUDIO_REG_AUDIO_RX_0_BIASSPEED));
    
        /* Set MC2BEN and MC2BDETEN*/
        power_ic_set_reg_mask(POWER_IC_REG_ATLAS_AUDIO_TX,
                             (POWER_IC_AUDIO_REG_AUDIO_TX_MC2BEN |
                              POWER_IC_AUDIO_REG_AUDIO_TX_MC2BDETEN),
                             (POWER_IC_AUDIO_REG_AUDIO_TX_MC2BEN |
                              POWER_IC_AUDIO_REG_AUDIO_TX_MC2BDETEN));
    }
    /* Release the mutex */
    up(&power_ic_debounce_audio_mutex);
}

/*!
 * @brief callback function to indicate headset status
 *
 * This function is called when the status of the headset changes.  The
 * function will report the new state of the accessory to the accessory driver
 * code.  The accessory driver will handle notifying any interested applications
 * of the event.
 *
 * The function also handles enabling and disabling of the headset send/end key
 * interrupt.  In order to prevent problems with spurious send/end key interrupts,
 * the send/end key interrupt (MB2) is not enabled until the headset has been
 * inserted and fully debounced.  Likewise, when the headset is removed, the
 * send/end key interrupt will be disabled.
 *
 * @param event pointer to the location in the event table
 * @param status current status of the headset
 */
static void headset_3mm5_handler(DEBOUNCE_EVENT_T *event, int status)
{
    MOTO_ACCY_MASK_T accessory;
    
    /* Get the currently connected accessories */
    accessory = moto_accy_get_all_devices();

    /* Aquire the mutex */
    down(&power_ic_debounce_audio_mutex);
    {    
        /* Headset not attached */
        if (status == debounce_events[DEBOUNCE_EVENT_INDEX_HEADSET].polarity)
        {
            /* Disable the send/end key event in the table */
            debounce_events[DEBOUNCE_EVENT_INDEX_MB2I].enabled = 0;

            /* Disable MC2BEN and MC2BDETEN */
            power_ic_set_reg_mask(POWER_IC_REG_ATLAS_AUDIO_TX,
                                 (POWER_IC_AUDIO_REG_AUDIO_TX_MC2BEN |
                                  POWER_IC_AUDIO_REG_AUDIO_TX_MC2BDETEN),
                                 0);
     
            /* Restore audio bias speed and bias enable settings */
            power_ic_set_reg_mask(POWER_IC_REG_ATLAS_AUDIO_RX_0,
                                 (POWER_IC_AUDIO_REG_AUDIO_RX_0_BIASEN |
                                  POWER_IC_AUDIO_REG_AUDIO_RX_0_BIASSPEED),
                                 power_ic_audio_set_reg_rx0_data);
    
            if (ACCY_BITMASK_ISSET(accessory, MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO_MIC))
            {
                tracemsg(_k_d("headset_3mm5_debounced: stereo headset with mic is removed\n"));

                if (previous_key_state == HEADSET_KEY_PRESS)
                {
                    /* Send a key release in case a key press was generated during the
                       removal of the headset, to avoid a long key press event */
                    generate_key_event(KEYPAD_HEADSET, KEYUP);
                }
                /* Notify the applications that the headset with mic has been removed */
                moto_accy_notify_remove(MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO_MIC);
            }

            if (ACCY_BITMASK_ISSET(accessory, MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO))
            {
                /* Notify the applications that the headset without mic has been removed */
                moto_accy_notify_remove(MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO);
            }
        
            previous_key_state = HEADSET_KEY_UNKNOWN;
        }

        /* Else, headset is attached */
        else
        {
            /* Clear the send/end key interrupt */
            power_ic_event_clear(POWER_IC_EVENT_ATLAS_MC2BI);
        
            /* Headset with mic */
            if (power_ic_event_sense_read(POWER_IC_EVENT_ATLAS_MC2BI))
            {
                if (ACCY_BITMASK_ISSET(accessory, MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO))
                {
                    /* Make sure the headset without mic is removed from the accessory driver */
                    moto_accy_notify_remove(MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO);
                }
            
                /* Notify the applications that the stereo headset with mic is attached */
                moto_accy_notify_insert(MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO_MIC);
            
                tracemsg(_k_d("headset_3mm5_debounced: stereo headset with mic is inserted\n"));
            }
            /* Headset without mic */
            else
            {
                if (ACCY_BITMASK_ISSET(accessory, MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO_MIC))
                {
                    /* Make sure the headset with mic is removed from the accessory driver */
                    moto_accy_notify_remove(MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO_MIC);
                }
            
                /* Notify the applications that the stereo headset without mic is attached */
                moto_accy_notify_insert(MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO);
            
                tracemsg(_k_d("headset_3mm5_debounced: stereo headset without mic is inserted\n"));
            }

            /* Unmask the send/end key interrupt */
            power_ic_event_unmask(POWER_IC_EVENT_ATLAS_MC2BI);
        
            /* Enable the primary send/end key event in the table */
            debounce_events[DEBOUNCE_EVENT_INDEX_MB2I].enabled = 1;

            /* Reset previous headset key value */
            previous_key_state = HEADSET_KEY_UNKNOWN;
        }
    
        /* 3mm5 headset debouncing completed */
        power_ic_debouncing_3mm5_headset=0;                        
    }
    /* Release the mutex */
    up(&power_ic_debounce_audio_mutex);
}

/*!
 * @brief Utility function to help setup for the next handler if an event needs mutliple handlers
 *
 * This function will setup the debounce thread variables for the current and next handler
 * function and will add the next handler to the debounce thread queue.
 */
static void setup_for_next_handler(DEBOUNCE_EVENT_INDEX_T index, DEBOUNCE_EVENT_INDEX_T next_index)
{
    /* Let the debounce thread know that the current event has not been fully handled */
    debounce_events[index].further_handling_needed = 1;
    
    /* Disable the current handler */
    debounce_events[index].enabled = 0;
    
    /* Enable the next handler */
    debounce_events[next_index].enabled = 1;
    
    /* Add the next debounce index to the queue */
    add_index(next_index);
}

/*!
 * @brief Preliminary detection function for the send/end key status
 *
 * This function will determine the state of the send/end key after a short debounce
 * period. If a send/end key release is detected, a notification of a release will
 * be sent to the key manager. If a send/end key press is detected, it is not possible
 * to determine if it was actually a press or if the headset is being removed (slowly).
 * In order to determine the difference a large delay will be used to give the user time
 * to fully remove the headset. Once the delay expired the key state will be debounced
 * again and the result of this final debouncing will determine the if the press was
 * valid.
 *
 * @param event pointer to the location in the event table
 * @param status current status of the headset
 */
static void headset_key_preliminary_handler(DEBOUNCE_EVENT_T *event, int status)
{
    MOTO_ACCY_MASK_T accessory;
    int hsdet_status;
    int hsdet_sense;
    
    /* Get the currently connected accessories */
    accessory = moto_accy_get_all_devices();
    
    if (ACCY_BITMASK_ISSET(accessory, MOTO_ACCY_TYPE_3MM5_HEADSET_STEREO_MIC))
    {
        if (status != debounce_events[DEBOUNCE_EVENT_INDEX_MB2I].polarity) /* key released */
        {
            tracemsg(_k_d("headset_key_preliminary_debounced: headset send/end key is released\n"));
            generate_key_event(KEYPAD_HEADSET, KEYUP);
            
            /* Keep track of the last state of the headset key */
            previous_key_state = HEADSET_KEY_RELEASE;

            /* Key detection is complete */
            debounce_events[DEBOUNCE_EVENT_INDEX_MB2I].further_handling_needed = 0;
        }
        else /* key pressed */
        {   
            /* Get the state of the headset detect interrupt */
            power_ic_get_reg_value(POWER_IC_REG_ATLAS_INT_STAT_1, 18, &hsdet_status, 1);

            /* Get the state of the headset detect sense bit */
            hsdet_sense = power_ic_event_sense_read(POWER_IC_EVENT_ATLAS_HSDETI);

            /* Generate send/end key press only if HSDET sense is one and HSDET status
               has not been generated */
            if ((hsdet_status == 0) && (hsdet_sense != 0))
            {
                setup_for_next_handler(DEBOUNCE_EVENT_INDEX_MB2I, DEBOUNCE_EVENT_INDEX_MB2I_DELAY);
            }
            else
            {
                /* The headset appears to be in the middle of being removed, ignore
                   key interrupt, key detection is complete*/
                debounce_events[DEBOUNCE_EVENT_INDEX_MB2I].further_handling_needed = 0;
            }
        }
    }
    else
    {
        /* If a mic bias interrupt is generated while the 3.5 mm headset without mic
           is attached a redetection of the headset is needed, because the headset
           is most likely a 3.5 mm headset WITH mic. */
        add_index(DEBOUNCE_EVENT_INDEX_HEADSET);
        
        /* Ignore key interrupt, key detection is complete */
        debounce_events[DEBOUNCE_EVENT_INDEX_MB2I].further_handling_needed = 0;
    }
}

/*!
 * @brief Delay function for detection of a false/valid 3.5 mm send end key press
 *
 * This function will be called after a preliminary key press is detected and a
 * large delay has passed. It will setup for the final key detection. See
 * headset_key_final_handler for more details.
 *
 * @param event pointer to the location in the event table
 * @param status current status of the headset
 */
static void headset_key_delay_handler(DEBOUNCE_EVENT_T *event, int status)
{
    setup_for_next_handler(DEBOUNCE_EVENT_INDEX_MB2I_DELAY, DEBOUNCE_EVENT_INDEX_MB2I_FINAL);
}

/*!
 * @brief Final valid/false key detection function for the 3.5 mm headset send/end key
 *
 * This function is called after the preliminary key detection has detected what appears
 * to be a key press, a long delay has expired and a final round of key debouncing has
 * completed. This function will determine if the key press detected in the preliminary
 * detection function was actually a press or slow removal of the 3.5 mm headset.
 * 
 * @param event pointer to the location in the event table
 * @param status current status of the headset
 */
static void headset_key_final_handler(DEBOUNCE_EVENT_T *event, int status)
{
    int hsdet_status;
    int hsdet_sense;
                
    if (status != debounce_events[DEBOUNCE_EVENT_INDEX_MB2I].polarity) /* key released */
    {
        tracemsg(_k_d("headset_key_final_debounced: headset send/end key is pressed\n"));
        
        /* This function will only be reached if the preliminary send/end key detection
           detected a key press. If by the time this function is called the key has been
           released, first send the press that was originally detected then send the release */
        generate_key_event(KEYPAD_HEADSET, KEYDOWN);
        
        tracemsg(_k_d("headset_key_final_debounced: headset send/end key is released\n"));
        generate_key_event(KEYPAD_HEADSET, KEYUP);
            
        /* Keep track of the last state of the headset key */
        previous_key_state = HEADSET_KEY_RELEASE;
    }
    else /* key pressed */
    {           
        /* Get the state of the headset detect interrupt */
        power_ic_get_reg_value(POWER_IC_REG_ATLAS_INT_STAT_1, 18, &hsdet_status, 1);
        
        /* Get the state of the headset detect sense bit */
        hsdet_sense = power_ic_event_sense_read(POWER_IC_EVENT_ATLAS_HSDETI);
            
        /* Generate send/end key press only if HSDET sense is one and HSDET status
           has not been generated */
        if ((hsdet_status == 0) && (hsdet_sense != 0))
        {
            tracemsg(_k_d("headset_key_final_debounced: headset send/end is pressed\n"));
            generate_key_event(KEYPAD_HEADSET, KEYDOWN);
            
            /* Keep track of the last state of the headset key */
            previous_key_state = HEADSET_KEY_PRESS;
        }
    }
    
    /* Disable final key handler */
    debounce_events[DEBOUNCE_EVENT_INDEX_MB2I_FINAL].enabled = 0;
    
    /* Enable the preliminary key handler */
    debounce_events[DEBOUNCE_EVENT_INDEX_MB2I].enabled = 1;
}

/*!
 * @brief Function to initialize the hardware for 3.5 mm headset detection.
 *
 * This function is called to initialize the hardware for detection of the 3.5 mm headset.
 */
static void headset_3mm5_init(void)
{ 
    /* Initialize the send/end key state variable */
    previous_key_state = HEADSET_KEY_UNKNOWN;
    
    /* Set hardware debouncing of the mic bias line to 30 ms */
    power_ic_set_reg_mask(POWER_IC_REG_ATLAS_AUDIO_TX,
                          POWER_IC_AUDIO_REG_AUDIO_TX_MC2BDETDBNC,
                          0);
    
    /* Disable auto clearing of the left and right amplifiers */
    power_ic_set_reg_mask(POWER_IC_REG_ATLAS_AUDIO_RX_0,
                          POWER_IC_AUDIO_REG_AUDIO_RX_0_HSDETAUTOB,
                          POWER_IC_AUDIO_REG_AUDIO_RX_0_HSDETAUTOB);
}

/*******************************************************************************
* Global Functions
*******************************************************************************/

/*!
 * @brief function to initialize the power IC debouncing thread
 *
 * This function does the initialization required to start the power IC
 * debouncing thread.  During the initialization, an event for each of the
 * enabled events from the event table is added into the queue to be
 * processed by the debouncing thread.  This is done to allow for power-up
 * determination of the state of each of the events (headset status, etc.)
 * rather than just having to wait for an interrupt from the power IC before
 * the state of the event can be determined.
 */
void power_ic_debounce_init (void)
{
    DEBOUNCE_EVENT_INDEX_T i = 0;
    
    /* Loop through the set of registered events */
    while (i < DEBOUNCE_EVENT_INDEX__NUM)
    {
        /* Reset the variables for this event */
        debounce_events[i].poll_current = 0;
        debounce_events[i].previous_status = -1;
        debounce_events[i].further_handling_needed = 0;

        /* Initialize the timer data for this entry */
        init_timer(&(debounce_events[i].timer));
        debounce_events[i].timer.data = i;
        debounce_events[i].timer.function = debounce_timer_handler;

        /* Register an event handler */
        power_ic_event_subscribe (debounce_events[i].event, debounce_interrupt_handler);

        if (debounce_events[i].event_init != NULL)
        {
            /* Call initialization function for the event */
            debounce_events[i].event_init();
        }
            
        /* If the entry is enabled, force an event for this entry, just to get things started */
        if (debounce_events[i].enabled)
        {
            add_index(i);
        }

        /* Move to the next event in the table */
        i++;
    }

    /* Start the debouncer kernel thread */
    kernel_thread (debounce_thread, NULL, 0);
}
